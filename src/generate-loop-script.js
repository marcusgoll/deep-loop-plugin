#!/usr/bin/env node

/**
 * Generate External Loop Script
 *
 * Creates a bash script for external loop mode orchestration.
 * The script runs Gemini CLI iteratively until DEEP_COMPLETE or max iterations.
 *
 * Task Sync Integration (v7.2.0):
 * - If DEEP_LOOP_TASKS_ENABLED=true, includes TaskList query for Ralph mode
 * - Allows multiple sessions to claim different atomic tasks
 */

import fs from 'fs';
import path from 'path';

/**
 * Generate loop.sh script for external loop mode
 * @param {Object} options Configuration options
 * @param {string} options.sessionId First 8 chars of session ID
 * @param {string} options.taskDescription Full task description
 * @param {number} options.maxIterations Max iterations (default 10)
 * @param {string} options.cwd Current working directory
 * @param {boolean} options.ralphMode Enable Ralph mode for multi-session task claiming
 * @param {boolean} options.taskSyncEnabled Enable Task Sync integration
 * @returns {string} Path to generated script
 */
export function generateLoopScript(options) {
  const {
    sessionId,
    taskDescription,
    maxIterations = 10,
    cwd = process.cwd(),
    ralphMode = false,
    taskSyncEnabled = process.env.DEEP_LOOP_TASKS_ENABLED === 'true'
  } = options;

  const deepDir = `.deep-${sessionId}`;
  const scriptPath = path.join(cwd, deepDir, 'loop.sh');

  // Escape task description for bash
  const escapedTask = taskDescription.replace(/'/g, "'\\''");

  // Task Sync prompt addition for Ralph mode
  const taskSyncPrompt = taskSyncEnabled ? `

TASK SYNC ENABLED:
${ralphMode ? `- Ralph Mode: Query TaskList() to claim unclaimed atomic tasks
- Filter by metadata.type === 'deep-loop-atomic' and status === 'pending'
- Claim task via TaskUpdate(taskId, { status: 'in_progress', owner: '${sessionId}' })
- Only work on tasks you've claimed` : `- Update task status at phase boundaries
- On task completion: TaskUpdate(taskId, { status: 'completed', metadata: { commitSHA: '...' } })`}` : '';

  const script = `#!/bin/bash
# Generated by /deep - External Loop Mode
# Session: ${sessionId}
# Task: ${escapedTask.slice(0, 80)}${escapedTask.length > 80 ? '...' : ''}
# Generated: ${new Date().toISOString()}
# Ralph Mode: ${ralphMode ? 'enabled' : 'disabled'}
# Task Sync: ${taskSyncEnabled ? 'enabled' : 'disabled'}

set -e
DEEP_DIR="${deepDir}"
LOG_FILE="$DEEP_DIR/loop.log"
TASK='${escapedTask}'
CWD="${cwd}"

# Telegram notification function
notify() {
  local status="$1"
  local message="$2"
  if [[ -n "\${TELEGRAM_BOT_TOKEN:-}" && -n "\${TELEGRAM_CHAT_ID:-}" ]]; then
    curl -s -X POST "https://api.telegram.org/bot\$TELEGRAM_BOT_TOKEN/sendMessage" \\
      -d chat_id="\$TELEGRAM_CHAT_ID" \\
      -d text="üîÑ Deep Loop [\$status]: \${TASK:0:50}...
\$message" \\
      -d parse_mode="Markdown" > /dev/null 2>&1 || true
  fi
}

# Ensure we're in the right directory
cd "$CWD" || { echo "Failed to cd to $CWD"; exit 1; }

# Gemini CLI path (installed globally via npm)
GEMINI_CLI="$HOME/AppData/Roaming/npm/node_modules/@google/gemini-cli/dist/index.js"

# Check dependencies
if ! command -v node &> /dev/null; then
  echo "Error: 'node' not found in PATH"
  exit 1
fi

if [[ ! -f "\$GEMINI_CLI" ]]; then
  echo "Error: Gemini CLI not found at \$GEMINI_CLI"
  echo "Install with: npm install -g @google/gemini-cli"
  exit 1
fi

echo "=========================================="
echo "  DEEP LOOP - EXTERNAL MODE"
echo "=========================================="
echo ""
echo "Session: ${sessionId}"
echo "Task: \${TASK:0:80}..."
echo "State: $DEEP_DIR/state.json"
echo "Log: \$LOG_FILE"
echo "Max iterations: ${maxIterations}"
echo "Ralph Mode: ${ralphMode ? 'enabled' : 'disabled'}"
echo "Task Sync: ${taskSyncEnabled ? 'enabled' : 'disabled'}"
echo ""
echo "Press Ctrl+C or 'touch $DEEP_DIR/FORCE_EXIT' to stop"
echo ""

notify "STARTED" "Beginning autonomous execution..."

iteration=0
max_iterations=${maxIterations}

while true; do
  iteration=\$((iteration + 1))
  timestamp=\$(date '+%Y-%m-%d %H:%M:%S')

  echo "[\$iteration/\$max_iterations] \$timestamp - Running iteration..."
  echo "---" >> "\$LOG_FILE"
  echo "[\$iteration] \$timestamp" >> "\$LOG_FILE"

  # Build the phase prompt
  PHASE_PROMPT="You are continuing a deep loop in external mode.

Read state from:
- $DEEP_DIR/state.json - Current phase and iteration
- $DEEP_DIR/plan.md - Implementation plan
- $DEEP_DIR/task.md - Original task
- $DEEP_DIR/issues.json - Current issues (if exists)

Execute the current phase according to the deep loop protocol.
Commit progress atomically after each task.
Output phase completion promise when phase is done.

IMPORTANT: External mode - assumptions are pre-approved. Proceed with the plan.
Do NOT ask for user confirmation - execute autonomously.
${taskSyncPrompt}
When ALL work is complete: <promise>DEEP_COMPLETE</promise>"

  # Run Gemini with the phase prompt (-y for yolo mode, auto-approves tools)
  if ! node "\$GEMINI_CLI" "\$PHASE_PROMPT" -y -o text 2>&1 | tee -a "\$LOG_FILE"; then
    echo "Gemini exited with error at iteration \$iteration" | tee -a "\$LOG_FILE"
    notify "ERROR" "Gemini exited with error at iteration \$iteration"
  fi

  # Check for DEEP_COMPLETE in state.json
  if [[ -f "$DEEP_DIR/state.json" ]]; then
    if grep -q '"complete": *true' "$DEEP_DIR/state.json" 2>/dev/null; then
      echo ""
      echo "=========================================="
      echo "  DEEP LOOP COMPLETE"
      echo "=========================================="
      echo "Iterations: \$iteration"
      notify "COMPLETE" "‚úÖ All tasks finished successfully! Iterations: \$iteration"
      exit 0
    fi
  fi

  # Check for FORCE_EXIT file
  if [[ -f "$DEEP_DIR/FORCE_EXIT" ]]; then
    echo ""
    echo "Force exit requested by user."
    rm -f "$DEEP_DIR/FORCE_EXIT"
    notify "CANCELLED" "Force exit by user at iteration \$iteration"
    exit 0
  fi

  # Safety: max iterations
  if [[ \$iteration -ge \$max_iterations ]]; then
    echo ""
    echo "Max iterations (\$max_iterations) reached without completion."
    echo "To continue: increase maxIterations in state.json and re-run"
    notify "LIMIT" "‚ö†Ô∏è Max iterations (\$max_iterations) reached without completion"
    exit 1
  fi

  # Brief pause between iterations (allows Ctrl+C)
  sleep 2
done
`;

  // Ensure directory exists
  const dirPath = path.join(cwd, deepDir);
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }

  // Write script
  fs.writeFileSync(scriptPath, script, { mode: 0o755 });

  return scriptPath;
}

/**
 * CLI entry point
 * Usage: node generate-loop-script.js <sessionId> <taskDescription> [maxIterations]
 */
if (process.argv[1] && process.argv[1].endsWith('generate-loop-script.js')) {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error('Usage: generate-loop-script.js <sessionId> <taskDescription> [maxIterations]');
    process.exit(1);
  }

  const sessionId = args[0];
  const taskDescription = args[1];
  const maxIterations = parseInt(args[2]) || 10;

  try {
    const scriptPath = generateLoopScript({
      sessionId,
      taskDescription,
      maxIterations,
      cwd: process.cwd()
    });
    console.log(`Generated: ${scriptPath}`);
  } catch (err) {
    console.error('Error generating script:', err.message);
    process.exit(1);
  }
}

export default generateLoopScript;
